// Copyright (c) 2017-2020 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        lightSpeed: { value: 1.0 }
        lightTime: { value: 0.0 }
        edgeWidth: { value: 0.1 }
        color1: { value: [1.0, 0.2, 0.2, 1.0], editor: { type: color } }
        color2: { value: [0.2, 1.0, 0.2, 1.0], editor: { type: color } }
        color3: { value: [0.8, 0.2, 1.0, 1.0], editor: { type: color } }
        color4: { value: [1.0, 1.0, 0.2, 1.0], editor: { type: color } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  #if SAMPLE_FROM_RT
    #include <common/common-define>
  #endif
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 color;
  out vec2 uv0;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    #if USE_PIXEL_ALIGNMENT
      pos = cc_matView * pos;
      pos.xyz = floor(pos.xyz);
      pos = cc_matProj * pos;
    #else
      pos = cc_matViewProj * pos;
    #endif

    uv0 = a_texCoord;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(uv0);
    #endif
    color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  in vec4 color;
  
  // 修正UBO内存对齐：vec4在前，float在后
  uniform LightParams {
    vec4 color1;
    vec4 color2;
    vec4 color3;
    vec4 color4;
    float lightSpeed;
    float lightTime;
    float edgeWidth;
  };

  #if USE_TEXTURE
    in vec2 uv0;
    #pragma builtin(local)
    layout(set = 2, binding = 12) uniform sampler2D cc_spriteTexture;
  #endif

  // 基于自定义颜色的平滑过渡
  vec3 getCustomColor(float progress) {
    progress = fract(progress);
    
    // 将4个颜色组成环形序列
    vec3 colors[5];
    colors[0] = color1.rgb;
    colors[1] = color2.rgb;
    colors[2] = color3.rgb;
    colors[3] = color4.rgb;
    colors[4] = color1.rgb; // 回到第一个颜色，形成无缝循环
    
    float segment = progress * 4.0; // 4个颜色区间
    float indexFloat = floor(segment);
    float blend = fract(segment);
    
    // 手动实现环形索引（兼容GLSL ES 1.0）
    vec3 colorA, colorB;
    if (indexFloat < 1.0) {
        colorA = colors[0];
        colorB = colors[1];
    } else if (indexFloat < 2.0) {
        colorA = colors[1];
        colorB = colors[2];
    } else if (indexFloat < 3.0) {
        colorA = colors[2];
        colorB = colors[3];
    } else {
        colorA = colors[3];
        colorB = colors[4];
    }
    
    // 平滑插值
    return mix(colorA, colorB, smoothstep(0.0, 1.0, blend));
  }

  vec4 frag () {
    vec4 o = vec4(1, 1, 1, 1);

    #if USE_TEXTURE
      o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);
      #if IS_GRAY
        float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;
        o.r = o.g = o.b = gray;
      #endif
    #endif

    // 计算边缘距离
    float leftEdge = uv0.x;
    float rightEdge = 1.0 - uv0.x;
    float bottomEdge = uv0.y;
    float topEdge = 1.0 - uv0.y;
    
    // 找到最近的边缘距离
    float minEdge = min(min(leftEdge, rightEdge), min(bottomEdge, topEdge));
    
    // 计算边缘强度
    float edgeStrength = 1.0 - smoothstep(0.0, edgeWidth, minEdge);
    
    // 计算跑马灯位置（一圈连续）
    float perimeter = 0.0;
    if (minEdge == leftEdge) {
      perimeter = uv0.y * 0.25; // 左边：0~0.25
    } else if (minEdge == topEdge) {
      perimeter = 0.25 + uv0.x * 0.25; // 顶边：0.25~0.5
    } else if (minEdge == rightEdge) {
      perimeter = 0.5 + (1.0 - uv0.y) * 0.25; // 右边：0.5~0.75
    } else {
      perimeter = 0.75 + (1.0 - uv0.x) * 0.25; // 底边：0.75~1.0
    }
    
    // 计算颜色进度（结合位置和时间）
    float colorProgress = fract(perimeter + lightTime * lightSpeed);
    
    // 使用自定义颜色
    vec3 customColor = getCustomColor(colorProgress);
    
    // 混合颜色
    vec3 finalColor = mix(o.rgb, customColor, edgeStrength);
    
    o.rgb = finalColor * color.rgb;
    o.a *= color.a;
    
    ALPHA_TEST(o);
    return o;
  }
}%